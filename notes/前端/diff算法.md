#### 真实dom解析流程

浏览器渲染的过程主要包括以下五步：

1. 浏览器获取到 HTML 文档并解析 DOM 树
2. 解析 CSS 构建层叠样式表模型CSSOM(CSS Object Model)
3. 将 DOM Tree 和 CSSOM 合并成一个 Render Tree
4. 有了Render Tree，浏览器便能获取到每个节点的 CSS 定义和从属关系，从而可以计算出每个节点的现实位置
5. 通过上一步的计算规则进行绘制页面

#### 虚拟dom产生的背景

用原生 js 或 jquery 去操作 DOM 时，浏览器会从构建 DOM 树到绘制渲染树这个过程全部执行一遍
容易造成页面卡顿，过多消耗的浏览器性能和内存的问题，虚拟 DOM 的出现就是为了解决这个问题

#### 虚拟dom的原理

虚拟DOM就是利用js运行速度快的这一优点对操作DOM进行优化的，用js模拟DOM树，在js中处理完对DOM的操作再渲染，简单概括分为以下三点：

1. 用javascript对象模拟DOM树并且渲染DOM树；

2. 通过 **diff算法** 比较新旧DOM树，得到差异的对象；

3. 将差异的对象应用到渲染的DOM树中。

   ```js
   //真实dom
   <div id="app">
       哈哈
       <p>123</p>
   </div>
   //虚拟dom
   var vNode = {
       tag: 'div',
       props: {id: 'app'},
       children: [
           {
               tag: 'p',
               props: {},
               children: [],
               context: '123'
           }
       ],
       context: '哈哈'
   }
   ```

   

#### diff算法背景

即使使用了Virtual DOM来进行真实DOM的渲染，在页面更新的时候，也不能全量地将整颗Virtual DOM进行渲染，而是去渲染需要改变的部分，这时候就需要一个计算Virtual DOM树改变部分的算法了，这个算法就是Diff算法。

#### diff算法的作用

Diff算法的作用是用来计算出 **Virtual DOM** 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面

#### 传统diff算法

传统的Diff算法通过循环递归对节点进行比较，然后判断每个节点的状态以及要做的操作（add，remove，change），最后 根据Virtual DOM进行DOM的渲染。

传统Diff算法的复杂度为O(n^3)，这个复杂度相对来说还是较高的

#### 高效的diff算法

##### 来源

React的开发者结合Web界面的特点做出了两个大胆的假设，使得Diff算法复杂度直接从O(n^3)降低到O(n)

1,两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构；

2，同一层级的一组节点，他们可以通过唯一的id进行区分。

基于以上两点假设，虚拟的DOM的Diff算法的复杂程度从O(n^3)降到了O(n)。

##### 过程

当页面的数据发上变化的时候，Diff算法只会比较同一层级的节点：

如果节点类型不同，直接干掉前面的节点，在创建并插入新的节点，不会再比较这个节点以后的子节点了。

如果节点类型相同，则会重新设置节点的属性，从而实现节点的更新。

当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上的原则

#### 三大策略

Tree Diff

Tree Diff 是对树每一层进行遍历，找出不同

Component Diff

Component Diff是数据层面的差异比较

Element Diff

Element Diff真实DOM渲染，结构差异的比较

三种策略的执行顺序也是顺序依次执行

#### 虚拟dom中key的作用

使用key来给每个节点做一个唯一的标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。key的作用就是为了高效的更新虚拟DOM

ps：key最好不要用index，用单一的唯一的标记

**用index作为key可能会引发的问题**：
	（1）若对数据进行：逆序添加、逆序删除等破坏顺序操作：
	会产生没有必要的真实DOM更新==>页面效果没问题，但效率低。
	（2）如果结构中还包含有输入类的DOM会产生错误dom更新--->界面有问题。
	（3）注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。
**开发中如何选择key**？：
	（1）最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值。
	（2）如果确定只是简单的展示数据，用index也是可以的。

#### vue和react vdom

vue 采用的虚拟 dom 通过重写 setter ， getter 实现观察者监听 data 属性的变化生成新的虚拟 dom， 通过 h 函数创建真实 dom 替换掉dom树上对应的旧 dom。
react 也是通过虚拟 dom 和 setState 更改 data 生成新的虚拟 dom 以及 diff 算法来计算和生成需要替换的 dom 做到局部更新的。

#### 为什么Vue和React都选择虚拟DOM

（1）减少直接操作DOM。框架给我们提供了屏蔽底层dom书写的方式，减少频繁的更新dom，
同时也使得数据驱动视图更新
（2）为函数式编程提供可能（React核心思想）
（3）可以跨平台，渲染到DOM（web）之外的平台。比如ReactNative，Weex

#### vue和react diff算法的对比

Vue基于snabbdom库，它有较好的速度以及模块机制
React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM

vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。

1.vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。

2.vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。

