##### element的el-popover在el-table中不显示

```js
scope._self.$refs[scope.$index].doClose()
```

##### element--table表格当前行row修改数据，视图不更新

```

```

##### npm install出现"Unexpected end of JSON input while parsing near"错误解决方法

npm cache clean --force

把文件夹npm-cache下的内容删除掉（清除cache）路径：C:/Users/PC/AppData/Roaming/npm-cache

##### 绝对定位元素挡住下方元素点击解决办法

 pointer-events:none; 表示它将捕获不到任何点击，而只是让事件穿透到它的下面。

 pointer-events:auto;表示鼠标不会穿透当前层, 鼠标事件仍会监听这个父元素下面的子元素。

外层div如果已经绝对或相对定位了（并且本层有点击事件或其他执行事件继续有效**，这两步执行后，外层的父元素上的事件会正常执行，同时下层元素也可点击**）：

##### 用 VSCode 调试 React 代码

我们在根目录下添加一个 .vscode/launch.json 的配置文件

```json
{
"configurations":[
		{
		"name":"Launch Chrome",
		"request":"launch",
		"type":"pwa-chrome", wurt:"nccp:77 Cocatnost:3000","webRoot":"${workspaceFolder}"
		}
	]
}
```

而且当你写业务累了，想摸鱼看会 react 源码，那直接点击调用栈里的某一帧看就行。
比如渲染的时候会调用 renderWithHooks 方法，里面的 workInProgress 对象就是当前 fiber 节点，它的 memorizedState 属性就是 hooks 存放值的地方：

##### 用 VSCode 调试 Vue 代码

Vue 的调试会麻烦一些，要在上面的基础上额外对路径做一些映射。

因为 React 我们是直接写 jsx、tsx，它和编译之后的 js 文件一一对应，而 Vue 不是，Vue 我们写的是 SFC（single file component） 格式的文件，需要 vue-loader 来把它们分成不同的文件，所以路径单独映射一下，才能对应到源码位置。

也就是调试配置里多了个 sourceMapPathOverrides：

```json
{
"configurations":[
		{
		"name":"Launch Chrome",
		"request":"launch",
		"type":"pwa-chrome", wurt:"nccp:77 Cocatnost:3000","webRoot":"${workspaceFolder}",
        "sourceMapPathOverrides":{}
		}
	]
}
```

**路径映射方法**

可以在源码里随便加个 debugger，在浏览器里看下现在映射的路径是啥

这里的 webpack://test-vue-debug/src/App.vue?11c4 就是要映射的路径，那映射到哪里呢？

很明显是映射到本地的路径，也就是这样：

```js
"webpack://test-vue-debug/src/*?11c4":"${workspaceRoot}/src/*"
```

workspaceRoot 是 vscode 提供的环境变量，就是项目的跟路径，这样一映射之后，地址不就变成本地的文件了么？那么在本地文件中打断点就能生效了

**但是映射的时候后面还带了个 hash，这个 hash 是会变得，怎么办呢？**

这个路径是可以配置的，这其实就是 webpack 生成 sourcemap 的时候的文件路径，可以通过 output.devtoolModuleFilenameTemplate 来配置：

```json
output:{
devtoolModuleFilenameTemplate:
'webpack://[namespace]/[resource-path]?[loaders]',
}
```

比如我把路径配成了这样：

```js
output:{
devtoolModuleFilenameTemplate
devtoo lModuleFilenameTemplate:'你相信光吗：//[resource-path]'
}
```

然后把它映射到本地文件：

```json
{
"configurations":[
		{
		"name":"Launch Chrome",
		"request":"launch",
		"type":"pwa-chrome", wurt:"nccp:77 Cocatnost:3000","webRoot":"${workspaceFolder}",
        "sourceMapPathOverrides":{
        	"你相信光吗://src/*":"${workspaceFolder}/src/*"
        }
		}
	]
}
```

##### element可搜索下拉框选中选项，切屏后，会自动获取焦点，然后菜单自动弹出了

原因：下拉框的filterable属性导致的

解决方法：选中选项后将选择框blur（失去焦点），调用组件的blur()方法。在change方法里面使用 nextTick

```js
this.nextTick(()=>{
	this.$refs.select1.blur();
})
```

##### 使用blob实现文件下载导出

 responseType: 'blob' 需要在axios设置responseType处理乱码

```js
function (fileName) {
  if (typeof window.navigator.msSaveBlob !== 'undefined') {
    window.navigator.msSaveBlob(new Blob([data]), fileName + '.xls')
  } else {
    let url = window.URL.createObjectURL(new Blob([data]))
    let link = document.createElement('a')
    link.style.display = 'none'
    link.href = url
    link.setAttribute('download', fileName + '.xls')
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link); //下载完成移除元素
    window.URL.revokeObjectURL(url); //释放掉blob对象
  }
};
```

##### 吸顶效果

需要监测元素的scroll事件 滚动到哪里触发

isFixed 的样式是 固定定位

```js
//参数   事件源对象
function (e) {
  if (e.target.scrollTop >= this.headerTop) {
    document.getElementsByClassName("is-stretch")[0].classList.add("isFixed");
  } else {
    document.getElementsByClassName("is-stretch")[0].classList.remove("isFixed");
  }
};
```

##### 在vue中嵌套iframe页面的一些问题

调用iframe页面中的方法

```js
this.$refs.video.contentWindow.方法名()
```

##### 判断手机端与浏览器

```js
(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent))
```

##### 判断移动端的 IOS android

```js
function mobile() {
  var u = navigator.userAgent;
  var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1; //android终端
  var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
  return isiOS
}
```

##### 判断是否是微信环境

```js
function getIsWxClient() {
  var ua = navigator.userAgent.toLowerCase()
  if (ua.match(/MicroMessenger/i) == 'micromessenger') {
    return true
  }
  return false
}
```

##### 生成一个随机颜色

```js
function rgb() {//rgb颜色随机
  var r = Math.floor(Math.random() * 256);
  var g = Math.floor(Math.random() * 256);
  var b = Math.floor(Math.random() * 256);
  var rgb = '(' + r + ',' + g + ',' + b + ')';
  return rgb;
}
```

##### 正则匹配模糊查询

```js
function selectMatchItem(lists, keyWord) {
  if (!keyWord) return;
  let reg = new RegExp(keyWord);
  let resArr = [];
  resArr = lists.filter(res => reg.test(res.speciesName));
  return resArr;
}
```

##### 利用canvas获取图片主颜色

**获取颜色**

```js
function getColor() {
  const canvas = document.createElement('canvas')
  const ctx = canvas.getContext('2d')
  const img = canvas.createImage()
  img.onload = () => {
    ctx.drawImage(img, 0, 0, 300, 150)
    const data = ctx.getImageData(0, 0, 300, 150).data;
    getUniqueColor(data)
    // img.src = that.data.swiperImgs[e.detail.current]
  }
}
```

**计算颜色**

```js
function getUniqueColor(imageData) {
  let res_r = 0
  let res_g = 0
  let res_b = 0
  let res_a = 0
  for (let i = 0; i < imageData.length; i += 1) {
    if (i % 4 === 0) {
      res_r += imageData[i]
    } else if (i % 4 === 1) {
      res_g += imageData[i]
    } else if (i % 4 === 2) {
      res_b += imageData[i]
    } else if (i % 4 === 3) {
      res_a += imageData[i]
    }
  }
  res_r = Math.round(res_r / (imageData.length / 4))
  res_g = Math.round(res_g / (imageData.length / 4))
  res_b = Math.round(res_b / (imageData.length / 4))
  res_a = Math.round(res_a / (imageData.length / 4))
  return `rgba(${res_r},${res_g},${res_b},${res_a})`
}
```

##### html5的接口FileReader将文件转换成base64编码格式

```js
function fileReader(files) {
  var fileReader = new FileReader()
  fileReader.readAsDataURL(files)
  fileReader.onload = event => {
    let originalUrl = event.target.result
    // 使用canvas进行图片压缩
  }
}
```

##### 使用canvas进行图片压缩

```js
function compressPicture(blob) {
  var quality = 0.5
  var image = new Image()
  image.setAttribute('crossOrigin', 'Anonymous')
  image.src = blob
  let vm = this
  image.onload = function () {
    var width = that.width
    var height = that.height
    width = width / 4
    height = height / 4
    var canvas = document.createElement('canvas')
    var ctx = canvas.getContext('2d')
    canvas.width = width
    canvas.height = height
    ctx.drawImage(that, 0, 0, width, height)
    let base64Url = canvas.toDataURL('image/jpeg', quality)
  }
}
```

##### 颜色转换

**rbga转16进制 两个参数 数组rgb 和 a**

```js
function rgbaToHexColor(rgbaArray, alphaMaxVal = 1) {
  //补位警号
  return "#" + rgbaArray.map((chanel, index) => {
    let hexNum = "";
    if (index === 3) {
      //这是alpha通道
      hexNum = Number(Math.round(chanel * 255 / alphaMaxVal)).toString(16);
    } else {
      //普通通道直接转换
      hexNum = Number(chanel).toString(16)
    }
    return hexNum.length === 1 ? '0' + hexNum : hexNum; //这里解决了部分通道数字小于10的情况进行补位
  }).join("");
}
```

**16进制转rbga 两个参数 **

```js
function hexColorToRgba(hexColor, alphaMaxVal = 1) {
  hexColor = hexColor.replace("#", "");
  //用于分割16进制色彩通道
  let reg = new RegExp("\\w{1,2}", "g");
  //分割颜色通道
  let rgbaArray255 = hexColor.match(reg);
  rgbaArray255 = rgbaArray255.map((channel, index) => {
    //计算每个通道的10进制值
    let colorVal = parseInt(channel, 16);
    if (index === 3) {
      //这是alpha通道
      return Math.round(colorVal / (255 / alphaMaxVal) * 100) / 100
    }
    return colorVal;
  });
  // return rgbaArray255;
  return "rgba(" + rgbaArray255.join(",") + ")";
}
```

##### 高德地图定位

```js
function getCoordinates() {
  let vm = this;
  AMap.plugin("AMap.Geolocation", function () {
    let geolocation = new AMap.Geolocation({
      enableHighAccuracy: true,
      timeout: 10000
    });
    geolocation.getCurrentPosition();
    //这里需要调用成功和失败两个回调函数
    AMap.event.addListener(geolocation, "complete", vm.onComplete);
    AMap.event.addListener(geolocation, "error", vm.onError);
  });
}
```

##### 计时器函数

```js
function calcTimer() {
  let timerRecord = { hour: '00', min: '00', second: '00' };
  let totalClock = 0;
  timerRecord.second = showNum(totalClock % 60);
  timerRecord.min = showNum(parseInt((totalClock / 60) % 60));
  timerRecord.hour = showNum(parseInt(totalClock / 60 / 60));
}
//封装一个处理单位数字的函数
function showNum(num) {
  if (num < 10) {
    return "0" + num;
  }
  return num;
}
```

生成带children的树结构

参数是数组

```js
function sortArr(arr) {
  // 深拷贝一份数据
  var copy = JSON.parse(JSON.stringify(arr));
  // 创建一个存储数据的对象
  var obj = {};
  // 遍历数据，将数据所有数据添加到对象中，key为数据id，value为原数据对象
  copy.forEach((item, index) => {
    obj[item.id] = item;
  });
  // 创建一个最终返回的数组
  var res = [];
  // 遍历数据开始处理
  copy.forEach(item => {
    // 将root数据添加进res数组， 因为数据使引用类型，子元素数据都会带过来，下面的循环会处理子元素数据
    if (item.parentId === 0) {
      res.push(item);
    }
    // 梳理子元素数据
    for (var key in obj) {
      //   当一层元素id 和 二层元素pId一致，那么，二层遍历的元素就是一层遍历元素的children
      if (item.id === obj[key].parentId) {
        // 处理数据children
        if (item.children) {
          item.children.push(obj[key]);
        } else {
          item.children = [obj[key]];
        }
      }
    }
  });
  return res;
}
```

##### 图片上传限制

```js
function imgBeforeUpload(file) {
  let types = ['image/jpeg', 'image/png'];
  const isImage = types.includes(file.type);
  const isLtSize = file.size / 1024 / 1024 < 5;
  if (!isImage) {
    this.$message.error('上传图片只能是 JPG、PNG 格式!');
    return false;
  }
  if (!isLtSize) {
    this.$message.error('上传图片大小不能超过 15MB!');
    return false;
  }
  return true;
}
```

##### 视频上传限制

```js
function videoBeforeUpload(file) {
  // let types = ['video/mp4', 'video/ogg', 'video/flv', 'video/avi', 'video/wmv', 'video/rmvb'];
  let types = ['video/mp4']
  const isVideo = types.includes(file.type);
  const isLtSize = file.size / 1024 / 1024 < 200;
  if (!isVideo) {
    this.$message.error('上传视频只能是 mp4 格式!');
    return false;
  }
  if (!isLtSize) {
    this.$message.error('上传图片大小不能超过 200MB!');
    return false;
  }
  return true;
}
```

##### 点击跳到对应的锚点 Vue 

```js
this.$refs.opt[index].scrollIntoView(true);
```

##### 递归函数 判断children添加

```js
function recursionFun(tempArr) {
  let newTempArr = JSON.parse(JSON.stringify(tempArr));
  let arr = [];
  newTempArr.map(item => {
    let obj= {
      id: item.id,
      value: item.id,
      label: item.label,
    };
     if (item.children.length > 0) {
      obj.children = this.recursionFun(item.children);
    }
    arr.push(obj)
  });
  return arr
}
```

