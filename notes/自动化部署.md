## devOps

### 定义

1. 字面意思是devlopment and operations，就是开发与运维，其中QA测试团队也包括其中

2. 含义就是让开发与运维和自动化测试，都协同应对同一套软件。通过自动化工具把整个软件的生命周期串联起来
3. 最终定义：Devops强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。

eg：开发把代码提交到github，其他的构建，测试，运维发布环境,都可以交给jenkins来做

## CI&CD

CI：Continuous Integration 持续集成
是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。

CD：Continuous Deployment 持续部署
是通过自动化的构建、测试和部署循环来快速交付高质量的产品。

## 手动部署

（1）将构建完毕的文件夹通过`xftp`传输到服务器`/usr/share/nginx/html`目录下

（2）将构建完毕的文件夹用`git`分支管理起来，推送到远程仓库，然后在`linux`服务器上拉取这部分代码

## 自动化部署(CI/CD 工具)

### jenkins

##### 简介

Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能

##### 部署环境

jdk环境，Jenkins是java语言开发的，因需要jdk环境。

git/svn客户端，因一般代码是放在git/svn服务器上的，我们需要拉取代码。

maven客户端，因一般java程序是由maven工程，需要maven打包，当然也有其他打包方式，如：gradle

##### Jenkins安装

首先看jenkins中文网

1.下载安装包[jenkins.war](http://mirrors.jenkins.io/war-stable/latest/jenkins.war)；

2.在安装包根路径下，运行命令 `java -jar jenkins.war --httpPort=8080，（linux环境、Windows环境都一样）；`

3.打开浏览器进入链接 [`http://localhost:8080`](http://localhost:8080/).

4.填写初始密码，激活系统`C:\User\Administrator\.jenkins\secrets\initialAdminPassword`(在这个目录找密码)

5.进入插件安装选择（这里建议选择，推荐安装的插件，保证基本常用的功能可以使用）

6.设置初始用户和密码

7.进入系统，安装完成

##### Jenkins基本配置

**1.Configure System (系统设置)**

在系统设置这里，我们只需要设置最后面的一项，配置远程服务器地址，即我们代码最终运行的服务器地址信息，就像我们之前手动部署时使用xshell登录Linux服务器一样，当然这里是可以配置多台远程Linux服务器的，配置完成后点击保存即可，为后面我们配置自动化部署做准备

**2. Configure Global Security (全局安全配置)**

a.配置用户相关的权限

b.配置钩子程序（当用代码更新时通知）访问权限，避免报403错误。默认是勾选上了的，这里去掉勾选

**3.Global Tool Configuration (全局工具配置 )**

a.配置maven的全局settings路径

b.配置jdk

c.配置git

d.配置maven的安装路径

**4.配置必要插件**

主要是检查如下这两个插件是否已安装

　　插件1：Publish over SSH
　　插件2：Deploy to container Plugin

##### Jenkins自动化部署

大体步骤：General(基础配置)--》源码管理--》构建触发器--》构建环境--》构建--》构建后操作

1.创建一个工程

2.General(基础配置)。仅需填写标准部分，其他可不填写

3.源码管理（点击“添加”按钮添加一组git仓库的账号和密码）

4.构建触发器（任意写一个token）

http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2

只要执行这个地址（在浏览器上访问改地址），该项目就会发起一次构建项目，即拉取代码打包部署操作，

在实际中，是由git服务器回调改地址，在后面讲git服务器配置时详细讲解 ，

值得注意的是，如果你是学习测试，使用的是GitHub服务，要确保你的回调地址已经试外网映射过的，即往外网可以访问

5.构建环境（无需配置）

6.构建

　到此，Jenkinds服务器配置完成，接下来我还有要配置Linux服务器和Git服务器。

##### GitHub服务器配置

在GitHub服务器上的指定项目里面配置上文中提到的回调地址（github\project\setting\webhooks）

特别注意：为了保证回调地址网可以使用，

我已经将地址：http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2，

通过花生壳进行外网映射为：http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2

**到这里所有配置搞定，只需修改代码，提交到git,然后访问程序看是否生效。**

##### 测试

1.测试代码

2.提交代码到git,触发构建

3.在GitHub服务器上去看，是否已经触发

4.在Jenkins的控制台查看是否，正在构建

### github action

**GitHub Actions**是GitHub自家的持续集成及自动化工作流服务

##### 操作过程

首先在仓库 1 的根目录下，创建 `.github/workflows/main.yml` 文件，这就是 GitHub Actions 功能的配置文件，用于告诉 GitHub 要做哪些事情，写入以下内容

```js
name: Deploy GitHub Pages
 
# 触发条件：在 push 到 master 分支后
on:
  push:
    branches:
      - master
 
# 任务
jobs:
  build-and-deploy:
    # 服务器环境：最新版 Ubuntu
    runs-on: ubuntu-latest
    steps:
      # 拉取代码
      - name: Checkout
        uses: actions/checkout@v2
        with:
          persist-credentials: false
 
      # 1、生成静态文件
      - name: Build
        run: npm install && npm run build
 
      # 2、部署到 GitHub Pages
      - name: Deploy
        uses: JamesIves/github-pages-deploy-action@releases/v3
        with:
          ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
          REPOSITORY_NAME: somenzz/somenzz.github.io
          BRANCH: master
          FOLDER: public
          #注意这里的 public 是仓库根目录下的 public，也就是 npm run build 生成静态资源的路径，比如有的人是 `docs/.vuepress/dist`
 
      # 3、同步到 gitee 的仓库
      - name: Sync to Gitee
        uses: wearerequired/git-mirror-action@master
        env:
          # 注意在 Settings->Secrets 配置 GITEE_RSA_PRIVATE_KEY
          SSH_PRIVATE_KEY: ${{ secrets.GITEE_RSA_PRIVATE_KEY }}
        with:
          # 注意替换为你的 GitHub 源仓库地址
          source-repo: git@github.com:somenzz/somenzz.github.io.git
          # 注意替换为你的 Gitee 目标仓库地址
          destination-repo: git@gitee.com:somenzz/somenzz.git
 
      # 4、部署到 Gitee Pages
      - name: Build Gitee Pages
        uses: yanglbme/gitee-pages-action@main
        with:
          # 注意替换为你的 Gitee 用户名
          gitee-username: somenzz
          # 注意在 Settings->Secrets 配置 GITEE_PASSWORD
          gitee-password: ${{ secrets.GITEE_PASSWORD }}
          # 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错
          gitee-repo: somenzz/somenzz
          # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在）
          branch: master
 
      # 5、部署到 somenzz.cn 服务器
      - name: rsync deployments
        uses: burnett01/rsync-deployments@4.1
        with:
          # 这里是 rsync 的参数 switches: -avzh --delete --exclude="" --include="" --filter=""
          switches: -avzh
          path: public/
          remote_path: /home/ubuntu/public/
          remote_host: somenzz.cn
          remote_port: 22
          remote_user: ubuntu
          remote_key: ${{ secrets.MY_UBUNTU_RSA_PRIVATE_KEY }}
```

on 表示触发条件

jobs 表示要做的工作

jobs 下的 step 表示要做的步骤，前一步失败，后面不会继续执行。

jobs 下的 step 下有 name、uses、with 等，表示一个 action。

name 表示 action 的名称，uses 表示使用哪个插件，with 表示传给插件的参数。

secrets.XXX 这个 XXX 表示本仓库的环境变量，配置在仓库设置里面的 secrets 菜单栏，都是加密的。


### Azure Pipeline

### Travis CI

### Circle CI

### docker

## 应用服务部署发展史

物理服务器部署——虚拟机部署

### 虚拟化发展史

#### 常用虚拟机

vmware  主要用于window平台

1. vmware workstation(个人学习使用，性能较低)

2. vmware esxi (企业版虚拟化)

virtualPC

virtualBox

KVM  linux下的虚拟机工具

#### 容器

容器技术docker

### 虚拟机技术

#### 虚拟化技术概念

虚拟化技术是一种资源管理技术，是将计算机(宿主机)的各种实体资源（cpu 内存 磁盘空间 网络适配器等等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境

对于一台计算机，我们可以简单地分为3层，物理硬件层，操作系统层，应用程序层

在虚拟机中运行的程序和服务，这些指定是交给虚拟机工具，虚拟机工具又交给宿主机（物理机）去执行，所以最终用的资源都是物理机的本体资源。虚拟机就相当于一个翻译官

#### 痛点

在同一宿主系统提供不同的任务

解决了硬件层面的硬件资源共享问题

#### 虚拟机部署形式

宿主机的cpu必须支持hypervisor虚拟化技术（主流cpu都支持，可能需要去主板开启这个功能）

##### 完整环境（云服务器理念）

宿主机+宿主机操作系统（window linux macOS）+虚拟机工具（vmware。。。）+在虚拟机安装的系统

宿主机配置足够高，可以安装多个虚拟机工具和虚拟机系统

##### 局限性

每一个虚拟机都是一个完整的系统，要分配系统资源，虚拟机多到一定程度的时候，操作系统本身的资源也会消耗殆尽，或者说必须扩容

### 容器技术

#### 历史背景

无论是基于翻译和模拟的全虚拟化技术、半虚拟化技术，还是有了CPU硬件加持下的全虚拟化技术，其虚拟化的目标都是一台完整的计算机，拥有底层的物理硬件、操作系统和应用程序执行的完整环境。
为了让虚拟机中的程序实现像在真实物理机器上运行“近似”的效果，背后的HyperVisor做了大量的工作，付出了“沉重”的代价。
但是虚拟机中的程序只是想要一个单独的执行执行环境，不需要你费那么大劲去虚拟出一个完整的计算机来。
**虚拟出一台计算机的成本高还是只虚拟出一个隔离的程序运行环境的成本高**？答案很明显是前者。一台物理机可能同时虚拟出10台虚拟机就已经开始感到乏力了，但**同时虚拟出100个虚拟的执行环境却还是能够从容应对，这对于资源的充分利用可是有巨大的好处。**
近几年大火的容器技术正是在这样的指导思想下诞生的。

#### 痛点

解决应用上层的资源消耗的难题  

统一环境和依赖以及兼容性等的问题

#### 概念

对进程进行封装隔离，属于操作系统层面的虚拟化技术。

由于隔离的进程独立于宿主机和其他隔离的进程，也被称之为容器。

利用容器可以实现开发 测试 生产环境的一致性，极大的减少运维成本

#### 容器和虚拟机的差异

##### 虚拟机

虚拟机是虚拟出一套硬件，在其上面运行一个完整的操作系统
例如我们使用KVM，指定系统镜像，然后装系统，最终可以使用，在该系统上再运行所需的应用程序。
KVM创建虚拟机时，指定较少的cpu，内存，硬盘等资源，虚拟机性能较低。

##### 容器

容器内的应用程序直接运行在宿主机的内核上，容器内没有自己的内核，也没有对硬件进行虚拟，因此容器比虚拟机更加轻便

##### 容器对比KVM的好处

· 容器能够提供宿主机的性能，而kvm虚拟机是分配宿主机硬件资源，性能较弱
· 同样配置的宿主机，最多可以启动t0个虚拟机的话，可以启动100+的容器数量。
· 启动一个KVM虚拟机，得有一个完整的开机流程，花费时间较长，或许得20S，而启动一个容器只需要1S。
· KVM需要硬件CPU的虚拟化支持，而容器不需要。

#### docker和k8s的区别

当容器和服务器的数量达到一定规模的时候，就会碰到管理的问题，即如何有效管理大量的服务器和容器，保证应用的稳定运行、方便升级和故障的快速解决

容器编排工具提供图形化界面或者命令行来管理容器和服务器集群，提供容器配置、任务发布、服务发现、负载均衡、系统监控和故障恢复、声明式系统配置以及有关容器部署和性能的规则和约束定义机制等

Google开发的Kubernetes从众多编排工具中脱颖而出，赢下了容器编排工具大战。相比Kubernetes，Docker原生编排工具Swarm在集群搭建和使用上要相对简单一些，学习和部署成本相对低一些。较新版本的Docker已经集成了Swarm。Swarm支持跨多个主机进行编排，管理较小规模的容器集群也绰绰有余，对于初学者也可以很快的部署和运行

### docker容器

#### 容器和docker的区别

**Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案**

传统的容器技术没有成为主流的原因是因为其未能提供标准化的应用运行时环境

以Docker为代表的新一代容器技术则从一开始就以提供标准化的运行时环境为目标，真正做到“build once, run anywhere”，可以将同一个构建版本用于开发、测试、预发布、生产等任何环境，并且做到了与底层操作系统的解耦。在此基础上还进一步发展出了CaaS（容器即服务）技术

Docker容器的本质是宿主机上的一个进程。Docker通过namespace实现了资源隔离，通过cgroups实现了资源限制。

#### 部署形式

本地程序代码开发完成之后，另外开发一个dockerfile脚本，将代码和环境依赖全部打包为一个镜像文件（docker image）

测试环境和生产环境直接放一份镜像文件，执行命令docker run就可以运行了

有了docke之后，只需要将程序打包为镜像，就可以直接发给其他机器，其他机器，只需要运行该镜像，这个程序就直接运行了，不需要再像以前一样，各种配置，各种询问

#### 镜像与容器

容器特别像一个虚拟机，容器中运行着一个完整的操作系统。可以在容器中装 Nodejs，可以执行`npm install`，可以做一切你当前操作系统能做的事情

镜像是一个文件，它是用来创建容器的。如果你有装过 Windows 操作系统，那么 Docker 镜像特别像“Win7纯净版.rar”文件

#### 核心组件

image 镜像，用于构造容器（运行应用程序所需要的环境，打包为镜像文件）

container 容器（应用程序就运行在容器中）

dockerhub 镜像仓库（保存镜像文件，提供上传，下载镜像）

dockerfile 将你部署项目的操作写成一个 部署脚本，且改脚本还能构建镜像文件

#### docker镜像原理