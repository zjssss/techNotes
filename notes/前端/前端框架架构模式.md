### 架构模式

#### mvc

MVC：Model   View   Controller

MVC模式的意思是，软件工程可以分成三个部分，进行单向数据流

- 视图（View）：用户界面。
- 控制器（Controller）：业务逻辑；在Controller里面把Model的数据赋值给View来显示（或者是View接收用户输入的数据然后由Controller把这些数据传给Model来保存到本地或者上传到服务器）。
- 模型（Model）：数据保存，获取数据的地方

通信方式：所有通信都是单向的

1. View 传送指令到 Controller
2. Controller 完成业务逻辑后，要求 Model 改变状态
3. Model 将新的数据发送到 View，用户得到反馈

缺点：Controller里面的代码非常臃肿且难以维护

#### mvvm

MVVM：Model、View、ViewModel

主要就是MVC中Controller演变成MVVM中的viewModel

 MVVM与MVC最大的区别就是：它实现了View和Model的自动同步，是双向数据流

**优点：**

1. 双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化。很好的做到数据的一致性

2. 由于控制器的功能大都移动到View上处理，大大的对控制器进行了瘦身

3. View的功能进一步强化，具有控制的部分功能

**缺点**

1. 数据绑定也使得bug很难被调试。比如你看到页面异常了，有可能是你的View的代码有bug，也可能是你的model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。

2. 数据双向绑定不利于代码重用。客户端开发最常用的是View，但是数据双向绑定技术，让你在一个View都绑定了一个model，不同的模块model都不同。那就不能简单重用view了

3. 一个大的模块中model也会很大，虽然使用方便了也很容易保证数据的一致性，但是长期持有，不释放内存就造成话费更多的内存。

#### mvvm双向绑定

（1）发布订阅者的设计模式: 一般通过发布和订阅消息的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)。

（2）脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，在指定的事件触发时进入脏值检测。

（3）数据劫持: vue.js 则是采用数据劫持结合发布订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

### jquery和mvvm的区别

在JQuery时期，如果需要刷新UI时，需要先取到对应的DOM再更新UI，这样数据和业务的逻辑就和页面有强耦合。

在MVVM中，UI是听数据驱动的，数据一旦改变就会刷新相应的UI，UI变化也会改变相应的数据。这种方式在开发中只需要关心数据的变化，不用直接去操作DOM。并且可以将一些可复用的逻辑放在一个ViewModel中，多个View复用这个ViewModel。

在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 的数据劫持，React的数据绑定

###  Angluar 的脏数据检测

当触发了指定事件后进入脏数据检测，这时期会调用$digest循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用$watch函数，然后再次调用$digest循环直到发现没有变化。所以这个过程可能会循环几次，一直到不再有数据变化发生后，将变更的数据发送到视图，更新页面展现。如果是手动对 ViewModel 的数据进行变更，为确保变更同步到视图，需要手动触发一次“脏值检测”。

脏数据检测虽然需要每次去循环遍历查看是否有数据变化，存在低效的问题，与Vue的双向绑定原理不同，但是脏数据检测能够同时检测出要更新的值，再去统一更新UI，这样也可以减少操作DOM的次数。

### Vue 的数据劫持

Vue2.0版本内部使用了Object.defineProperty()来实现数据与视图的双向绑定，体现在对数据的读写处理过程中。即Object.defineProperty()中定义的数据set、get函数。

Vue3.0将用proxy代替Object.defineProperty()

### React的数据绑定

React的数据绑定是虚拟DOM树的更新相关：
属性更新，组件自己处理