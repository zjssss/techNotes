### TCP协议入门

#### 连接管理机制

正常情况下, tcp需要经过三次握手建立连接, 四次挥手断开连接

#### 三次握手

第一次:
客户端 - - > 服务器 此时服务器知道了客户端要建立连接了
第二次:
客户端 < - - 服务器 此时客户端知道服务器收到连接请求了
第三次:
客户端 - - > 服务器 此时服务器知道客户端收到了自己的回应

到这里, 就可以认为客户端与服务器已经建立了连接

##### 为什么不用两次

主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。
如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

##### 为什么不用四次

因为三次已经可以满足需要了, 四次就多余了.

#### 四次挥手

数据传输完毕后，双方都可以释放连接.
此时客户端和服务器都是处于ESTABLISHED状态，然后客户端主动断开连接，服务器被动断开连接

### http协议和Tcp协议的区别

TPC/IP协议是传输层协议，主要解决数据如何在网络中传输；HTTP是应用层协议，主要解决如何包装数据
从本质上来说，二者没有可比性

http协议是在Tcp协议之上建立的，http在发起请求时通过tcp协议建立起连接服务器的通道，请求结束后，立即断开tcp连接

Http是无状态的短连接，而TCP是有状态的长连接

我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上

### http协议入门

#### 概述

HTTP 协议（是超文本传输协议的缩写）是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点

HTTP 是基于 TCP/IP 协议的[**应用层协议**](https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。

#### http/0.9

最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令`GET`

协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。

```json
GET /index.html
```

上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页`index.html`。

```js
<html>
  <body>Hello World</body>
</html>
```

服务器发送完毕，就关闭TCP连接

#### HTTP/1.0

##### 概述

1996年5月，HTTP/1.0 版本发布，内容大大增加。

首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。其次，除了`GET`命令，还引入了`POST`命令和`HEAD`命令，丰富了浏览器与服务器的互动手段。再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等

##### Content-Type 字段

1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。

因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是`Content-Type`字段的作用

```js
text/plain
text/html
text/css
image/jpeg
image/png
image/svg+xml
audio/mp4
video/mp4
application/javascript
application/pdf
application/zip
application/atom+xml
```



##### Content-Encoding 字段

由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。

`Content-Encoding`字段说明数据的压缩方法。

```js
Content-Encoding: gzip
Content-Encoding: compress
Content-Encoding: deflate
```

##### 缺点

每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了

为了解决这个问题，有些浏览器在请求时，用了一个非标准的`Connection`字段。这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。

```js
Connection: keep-alive
```



#### HTTP/1.1

##### 概述

1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。

它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。

##### 持久连接

1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭TCP连接

目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接

##### 管道机制

1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。

这样就进一步改进了HTTP协议的效率。

举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。

##### Content-Length 字段

一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。

这就是`Content-length`字段的作用，声明本次回应的数据长度

```js
Content-Length: 3495
```

上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了

##### 其他功能

1.1版还新增了许多请求方法：`PUT`、`PATCH`、`HEAD`、 `OPTIONS`、`DELETE`

客户端请求的头信息新增了`Host`字段，用来指定服务器的域名

有了`Host`字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础

##### 缺点

虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为["队头堵塞"](https://zh.wikipedia.org/wiki/队头阻塞)（Head-of-line blocking）。

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。

这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。

#### SPDY 协议

2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。

这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。

#### HTTP/2

##### 概述

2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。

##### 二进制协议

HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。

HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。

##### 多工

HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。

这样双向的、实时的通信，就叫做多工（Multiplexing）。

##### 数据流

因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号（`RST_STREAM`帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

##### 头信息压缩

HTTP 协议不带有状态，每次请求都必须附上所有信息。

所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，

这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用`gzip`或`compress`压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

##### 服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

### http1和http2的区别

1. HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送
   二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示
   二进制格式在协议的解析和优化扩展上带来了跟多的优势和可能
2. HTTP2支持多路复用，而非有序并阻塞的——只需一个连接即可实现并行
3. 对消息头采用Hpack进行压缩传输，能够节省消息头占用的网络流量，http1.1每次请求，都会携带大量冗余的头信息，浪费了很多宽带资源
4. HTTP/2让服务器可以将响应主动“推送”到客户端缓存中

### http和https的区别

HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

#### 两者主要区别

 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。HTTPS 相对于 HTTP 的改进

ssl全称是Secure Sockets Layer，即安全接层，是一种标准协议，用于加密浏览器和服务器之间的数据传输，确保隐私数据的安全性和完整性。所以网站都会安装ssl证书

### http状态码

1xx : 表示请求已经接受了，继续处理。
2xx : 表示请求已经处理掉了。
3xx : 重定向。
4xx : 一般表示客户端有错误，请求无法实现。
5xx : 一般为服务器端的错误

200:请求已成功
302:请求的资源临时从不同的 URL 响应请求（重定向）
304：所请求的资源未修改，不会返回任何资源。客户端通常会缓存访问过的资源
400：请求参数错误
401：请求要求用户的身份认证（带上请求头cookie或者token）
403:拒绝执行它
404:请求资源不存在请（求路径错误）
500:服务器端内部的错误
502：错误网关，服务器作为网关或代理，从远端服务器接收到了一个无效的请求
504：请求超时
505：不支持的版本协议

# 一个HTTP请求都包含了什么

通用头：General Header
请求头：Request Headers
请求体：Request Body
响应头：Response Headers