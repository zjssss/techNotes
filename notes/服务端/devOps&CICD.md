## devOps概述

1. DevOps 就是开发（Development）、测试（QA）、运维（Operations）这三个领域的合并。虽然名字中没有体现，但是DevOps仍包括测试
2. 含义就是让开发与运维和自动化测试，都协同应对同一套软件。通过自动化工具把整个软件的生命周期串联起来
3. 最终定义：Devops强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。
4. DevOps是一种思想、一组最佳实践、以及一种文化。DevOps落地实施，从组织架构、设计人员、流程、人员分工、人员技能到工具，变化很大，要求很高，完全颠覆了现有的开发运维模式，建设风险很高

eg：开发把代码提交到github，其他的构建，测试，运维发布环境,都可以交给jenkins来做

## CI&CD概念

CI：Continuous Integration 持续集成
是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。

CD：Continuous Deployment 持续部署
是通过自动化的构建、测试和部署循环来快速交付高质量的产品。

## CICD和DevOps的区别

个人理解，CICD更关注的是整个开发，测试，部署的自动化的过程，当我们在本地单元测试通过后，我们提交到git上，触发相应的webhook或者类似的东西进行代码的构建，并打包部署到相应的机器上，自动化的完成这整个过程。

而DevOps更关注的是打通用户、PMO、需求、设计、开发（Dev）、测试、运维（Ops）等各上下游部门或不同角色；打通业务、架构、代码、测试、部署、监控、安全、性能等各领域工具链；尤其是打通开发与运维之间的gap，因为两者实际上存在着很多的冲突。DevOps是基于CICD的，自动化的流程是基础，DevOps是一个项目由idea到实际稳定运行的产品的一个最佳实践。

DevOps是CICD思想的延伸，CICD是DevOps的基础核心，如果没有CICD自动化的工具和流程，DevOps是没有意义的



## 手动部署

（1）将构建完毕的文件夹通过`xftp`传输到服务器`/usr/share/nginx/html`目录下

（2）将构建完毕的文件夹用`git`分支管理起来，推送到远程仓库，然后在`linux`服务器上拉取这部分代码想

## 自动化部署(CI/CD 工具)

### jenkins

### github action

**GitHub Actions**是GitHub自家的持续集成及自动化工作流服务




### Azure Pipeline

### Travis CI

### Circle CI

### git-webhook

### docker

### k8s

### rancher

主流的**Kubernetes**集群管理平台

### dokku



## 应用服务部署发展史

物理服务器部署
虚拟化部署
容器部署

### 虚拟化发展史

### 虚拟机技术

vmware  主要用于window平台

1. vmware workstation(个人学习使用，性能较低)

2. vmware esxi (企业版虚拟化)

virtualPC

virtualBox

KVM  linux下的虚拟机工具

> 虚拟化技术概念

虚拟化技术是一种资源管理技术，是将计算机(宿主机)的各种实体资源（cpu 内存 磁盘空间 网络适配器等等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境

对于一台计算机，我们可以简单地分为3层，物理硬件层，操作系统层，应用程序层

在虚拟机中运行的程序和服务，这些指定是交给虚拟机工具，虚拟机工具又交给宿主机（物理机）去执行，所以最终用的资源都是物理机的本体资源。虚拟机就相当于一个翻译官

> 痛点

在同一宿主系统提供不同的任务

解决了硬件层面的硬件资源共享问题

> 虚拟机部署形式

宿主机的cpu必须支持hypervisor虚拟化技术（主流cpu都支持，可能需要去主板开启这个功能）

**完整环境（云服务器理念）**

宿主机+宿主机操作系统（window linux macOS）+虚拟机工具（vmware。。。）+在虚拟机安装的系统

宿主机配置足够高，可以安装多个虚拟机工具和虚拟机系统

**局限性**

每一个虚拟机都是一个完整的系统，要分配系统资源，虚拟机多到一定程度的时候，操作系统本身的资源也会消耗殆尽，或者说必须扩容

### 容器技术

容器技术docker

#### 历史背景

无论是基于翻译和模拟的全虚拟化技术、半虚拟化技术，还是有了CPU硬件加持下的全虚拟化技术，其虚拟化的目标都是一台完整的计算机，拥有底层的物理硬件、操作系统和应用程序执行的完整环境。
为了让虚拟机中的程序实现像在真实物理机器上运行“近似”的效果，背后的HyperVisor做了大量的工作，付出了“沉重”的代价。
但是虚拟机中的程序只是想要一个单独的执行执行环境，不需要你费那么大劲去虚拟出一个完整的计算机来。
**虚拟出一台计算机的成本高还是只虚拟出一个隔离的程序运行环境的成本高**？答案很明显是前者。一台物理机可能同时虚拟出10台虚拟机就已经开始感到乏力了，但**同时虚拟出100个虚拟的执行环境却还是能够从容应对，这对于资源的充分利用可是有巨大的好处。**
近几年大火的容器技术正是在这样的指导思想下诞生的。

#### 痛点

解决应用上层的资源消耗的难题  

统一环境和依赖以及兼容性等的问题

#### 概念

对进程进行封装隔离，属于操作系统层面的虚拟化技术。

由于隔离的进程独立于宿主机和其他隔离的进程，也被称之为容器。

利用容器可以实现开发 测试 生产环境的一致性，极大的减少运维成本

#### 容器和虚拟机的差异

> 虚拟机

虚拟机是虚拟出一套硬件，在其上面运行一个完整的操作系统
例如我们使用KVM，指定系统镜像，然后装系统，最终可以使用，在该系统上再运行所需的应用程序。
KVM创建虚拟机时，指定较少的cpu，内存，硬盘等资源，虚拟机性能较低。

> 容器

容器内的应用程序直接运行在宿主机的内核上，容器内没有自己的内核，也没有对硬件进行虚拟，因此容器比虚拟机更加轻便

> 容器对比KVM的好处

· 容器能够提供宿主机的性能，而kvm虚拟机是分配宿主机硬件资源，性能较弱
· 同样配置的宿主机，最多可以启动t0个虚拟机的话，可以启动100+的容器数量。
· 启动一个KVM虚拟机，得有一个完整的开机流程，花费时间较长，或许得20S，而启动一个容器只需要1S。
· KVM需要硬件CPU的虚拟化支持，而容器不需要。

#### docker和k8s的区别

当容器和服务器的数量达到一定规模的时候，就会碰到管理的问题，即如何有效管理大量的服务器和容器，保证应用的稳定运行、方便升级和故障的快速解决

容器编排工具提供图形化界面或者命令行来管理容器和服务器集群，提供容器配置、任务发布、服务发现、负载均衡、系统监控和故障恢复、声明式系统配置以及有关容器部署和性能的规则和约束定义机制等

Google开发的Kubernetes从众多编排工具中脱颖而出，赢下了容器编排工具大战。相比Kubernetes，Docker原生编排工具Swarm在集群搭建和使用上要相对简单一些，学习和部署成本相对低一些。较新版本的Docker已经集成了Swarm。Swarm支持跨多个主机进行编排，管理较小规模的容器集群也绰绰有余，对于初学者也可以很快的部署和运行



