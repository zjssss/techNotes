#### 异步加载js文件

##### defer 属性

加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本的执行需要等到文档所有元素解析完成之后，会在DOMContentLoaded事件触发执行之前

```js
<script src="test1.js" defer="defer"></script>
```

##### async 属性

表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行

```js
<script src="test1.js" async></script>
```

##### async和defer的区别

（1）defer和async在网络加载过程是一致的，都是异步执行的；
（2）两者的区别在于脚本加载完成之后何时执行，可以看出defer更符合大多数场景对应用脚本加载和执行的要求；
（3）如果存在多个有defer属性的脚本，那么它们是按照加载顺序执行脚本的；而对于async，它的加载和执行是紧紧挨着的，无论声明顺序如何，只要加载完成就立刻执行，它对于应用脚本用处不大，因为它完全不考虑依赖。

#####  动态创建DOM方式

```js
 function downloadJSAtOnload() { 
       var element = document.createElement("script"); 
       element.src = "test1.js"; 
       document.body.appendChild(element); 
   } 
```

##### 使用jQuery的getScript()方法

##### 使用setTimeout延迟方法

##### 让js最后加载

引入外部js脚本文件时，如果放入html的head中,则页面加载前该js脚本就会被加载入页面，而放入body中，则会按照页面从上倒下的加载顺序来运行javascript的代码，所以我们可以把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度

#### 浏览器内核

IE：triden(腾讯,猎豹,360 等浏览器)
FireFox:gecko(跨平台内核,windows,linux 和 mac os 中可以使用)
Chrome:Blink
Safari:webkit(苹果公司的内核,遨游浏览器,塞班手机浏览器,安卓默认浏览器)
未来:Mozilla 与三星也达成合作协议开发"下一代"浏览器渲染引擎 Servo.

#### WEB 标准以及前端页面三层

web 标准简单来说可以分为 结构层（html）、表现层（css）和行为层（js）
web 标准三层分离,使其更具有模块化

#### 从用户刷新网页开始, 一次 js 请求一般情况下有哪些地方会有缓存处理

DNS 缓存(成功访问后网站的域名、IP 地址信息缓存到本地）
CDN 缓存(内容分发网络,选择一个离用户最近的 CDN 边缘节点来响应用户的请求)
浏览器缓存(存储最近访问的过的页面,再次请求时,从本地磁盘显示文档来加速页面的阅览,节约网络的资源加速浏览)

#### 大量图片加载很慢,有哪些方法优化

图片懒加载（未可视区添加滚动事件  js库  Vue-Lazyload）
图片预加载
如果图片为 css 图片,可以使用 CSSsprite 精灵图、SVGsprite 矢量图、Iconfont 字体图标、Base64 等技术.
预先加载缩略图

#### src 与 href 的区别

src 用于替换当前元素(引入),href 用于在当前文档和引用资源之间确立联系(关联)
src指向外部资源（js脚本，img图片，iframe）的位置,指向的内容将会嵌入到文档中当前标签所在位置
当浏览器解析到该元素时,会暂停其他资源的下载和处理,直到将该资源加载、编译、执行完毕
href指向网络资源所在位置,建立和当前元素(锚点)或当前文档(链接)之间的链接

#### 哪些操作会造成内存泄漏

未声明的意外的全局变量引起的内存泄露（避免创建全局变量）
没有清理的DOM元素引用(手动删除)
被遗忘的定时器或者回调(手动删除定时器)
闭包引起的内存泄露(将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中)
控制台日志
循环(在两个对象彼此引用且彼此保留时,就会产生一个循环)

#### **ES6 防止内存泄漏**

ES6推出了两种新的数据结构：weakset 和 weakmap 。他们对值的引用都是不计入垃圾回收机制的，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存。

#### javascript 中的垃圾回收机制

解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。

在 Javascript 中,如果一个对象不再被引用,那么这个对象就会被回收.
如果两个对象互相引用,而不再被第 3 者所引用,那么这两个互相引用的对象也会被回收

 js中最常用的垃圾收集方式是标记清除，比较不常见的引用计数

#### 谈谈 this 对象的理解

普通函数中:this ==》window
定时器中:this==》window
构造函数中:this==》当前实例对象
对象的方法中:this==》当前实例对象
原型对象的方法中:this==》当前实例对象
事件处理函数中:this==》事件触发对象

定时器函数window
立即执行函数window

#### eval 是做什么的

把对应的字符串解析成 JS 代码并运行
eval()可能会被黑,如使用恶意代码获取权限
eval()非常耗性能（2次，一次是解析成js语句，一次是执行）

#### ajax 请求时,如何解析 json 数据

使用 eval() 或者 JSON.parse()解析

#### JavaScript 的同源策略

同源是一种安全协议,指的是:协议,域名,端口相同

#### 谈谈你认为怎样做能使项目做的更好

1)了解需求:不要以主观去认为需求,
2)代码的可维护性:便于后期开发和维护,拓展
3)清晰的文件目录:便于查找管理文件,优化 I/O
4)上线前严格的测试:确保上线没问题
5)良好的用户体验

#### javaScript作用域链

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。
如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

#### HTML5新特性

新增了一些语义化标签（header footer content）和input
canvas画布功能
draggable元素拖放
Geolocation 地理定位功能
用于媒介回放的 video 和 audio 元素
表单控件，calendar、date、time、email、url、search
web本地离线存储
离线web应用，启用缓存，可以离线访问，降低服务器压力
WebSocket长连接
媒体查询
新增的一些css3动画效果

#### js事件流

事件流描述的是页面中接受事件的顺序，微软称为事件冒泡，网景称为事件捕获
事件流包括三个阶段，分别是捕获阶段，目标阶段，冒泡阶段
当事件发生时，最先得到通知的是window，然后是document，由上至下直到真正触发事件的那个元素(目标元素)为止，这个过程就是捕获。
接下来，事件会从目标元素开始起泡，由下至上逐级依次传播，直到window对象为止，这个过程就是冒泡。

事件代理的好处:利用事件冒泡，只绑定一个函数就可以处理一类事件
优化性能（每个函数都是一个对象，对象就要占据内存，内存大了性能自然就慢了）
当新元素绑添加进来的时候不需要再次绑定事件，通过冒泡就可以触发

阻止事件冒泡和捕获：e. stopPropagation()
阻止默认事件：e.preventDefault()

#### js数据类型

js数据类型被分为了两大类型：基本类型和引用类型（7种）
基本类型：Undefined,Null,Boolean,Number,String
引用类型：Object（Array,Date,RegExp，Function） symbol

##### 基本方法

typeof 用于判断基本类型

instance 用于判断引用类型

##### 判断js数据类型通用方法

```js
Object.prototype.toString.call() / ({}).toString.call()

var   gettype=Object.prototype.toString
 
gettype.call('aaaa')  // 输出 [object String]
 
gettype.call(2222)  // 输出 [object Number]
 
gettype.call(true)  // 输出 [object Boolean]
 
gettype.call(undefined)  // 输出 [object Undefined]
 
gettype.call(null)  // 输出 [object Null]
 
gettype.call({})  // 输出 [object Object]
 
gettype.call([])  // 输出 [object Array]
gettype.call(function(){})  // 输出 [object Function]
```

#### dom（浏览器）渲染的过程

浏览器解析html源码，然后创建一个DOM树。
浏览器解析CSS代码，计算出最终的样式数据（CSS树）。
创建完DOM树并得到最终的样式数据（CSS树）之后，构建一个渲染树。
当渲染树创建完成之后，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

#### 一个页面从输入 URL 到页面加载显示完成,这个过程中都发生了什么

（1）输入网址，将域名解析成IP地址（解析url）
（2）检查浏览器缓存
（3）开始DNS解析
（4）浏览器与服务器建立tcp协议连接（三次握手，建立连接）（TCP/IP连接）
（5）浏览器发送http请求，请求url对应的资源
（6）服务器处理http请求，给浏览器返回响应的资源
（7）接收到服务器响应内容之后，浏览器的html解析器会将HTML文件解析成一个DOM树，将CSS解析成一个CSS树，根据DOM树和CSS树来构建 Render Tree(渲染树)。根据渲染树的对应关系 在客户端呈现内容画面
（8）断开TCP连接

#### 回流（Reflow）与重绘（Repaint）

##### 回流

当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，
浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），
然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。

##### 重绘

当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，
浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。

##### 对比

由此我们可以看出，重绘不一定导致回流，回流一定会导致重绘。
硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。

#### 节流函数和防抖函数

“节流”与“防抖”的本质： 这两个东西都以闭包的形式存在。用 setTimeout 来控制事件的触发频率。
节流函数：当你触发一个事件后，在一段时间内，再次触发是不启作用的，因为有一个冷却时间。
防抖函数：当你在一定时间内多次触发一个事件时，他只会在你最后触发以后，采取执行查询操作。

完整版封装一般我们都使用lodash封装好的

##### 防抖

```js
function debounce(fn,delay){
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer) 
        }
        timer = setTimeout(fn,delay) // 简化写法
    }
}
// 然后是旧代码
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log('滚动条位置：' + scrollTop);
}
window.onscroll = debounce(showTop,1000)
```

##### 节流

加上一个状态位`valid`来表示当前函数是否处于工作状态

也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在

```js
function throttle(fn,delay){
    let valid = true
    return function() {
       if(!valid){
           //休息时间 暂不接客
           return false 
       }
       // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false
        setTimeout(() => {
            fn()
            valid = true;
        }, delay)
    }
}
```



#### 前端javaScript模块化的发展史

1 IIFE：使用自执行函数来编写模块化  特点：在一个单独的函数作用域中执行代码，避免变量冲突
2 AMD： 使用requireJS 来编写模块化，特点：提前执行，前置依赖。（异步模块定义）
3 CMD： 使用seaJS 来编写模块化，特点：延迟执行，就近依赖，按需加载。
4 CommonJS： nodejs 中自带的模块化（同步模块定义）
5 UMD：兼容AMD，CommonJS 模块化语法
       UMD的实现:
       1 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。
       2 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。
       3 前两个都不存在，则将模块公开到全局（window或global）
6 ES Modules： ES6 引入的模块化，支持import 来引入另一个 js 。

#### CommonJS

CommonJS是一种被广泛使用的js模块化规范，核心思想是通过require方法来同步加载依赖的其他模块，通过module.exports导出需要暴露的接口。
优点:
代码可复用于 Node.js 环境下井运行,通过 Npm 发布的很多第三方模块都采用了 CommonJS 规范
缺点：代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5



#### 代码优化

代码量(命名空间,封闭空间,模块化 mvc..)
拆分函数避免函数过于臃肿:单一职责原则
适当的注释,尤其是一些复杂的业务逻辑或者是计算逻辑,都应该写出这个业务逻辑的具体过程
内存管理,尤其是闭包中的变量释放



#### 平时如何管理你的项目,如何设计突发大规模并发架构

1)先期团队必须确定好全局样式(globe.css),编码模式(utf-8) 等
2)编写习惯必须一致(例如都是采用继承式的写法,单样式都写成一行);
3)标注样式编写人,各模块都及时标注(标注关键样式调用的地方);
4)页面进行标注(例如 页面 模块 开始和结束);
5)CSS 跟 HTML 分文件夹并行存放,命名都得统一(例如 style.css)
6)JS 分文件夹存放 命民以该 JS 功能为准英文翻译;
7)图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理

#### 一个完整的URL应该包括哪些

一个完整的URL包括：服务方或协议，主机地址或端口，资源的具体地址
通过URL可以指定的主要有以下几种：http、ftp、gopher、telnet、file等。

#### 关于跨域（cors怎么解决跨域）

跨域问题的出现，是因为浏览器的同源策略对ajax请求进行阻拦了
解决方法：CORS跨域资源共享，nginx反向代理，node代理服务器，后端设置响应头（response.setHeader("Access-Control-Allow-Origin", "*")）
1 CORS是一个W3C标准，全称是"跨域资源共享"
2 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制
3 浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求（特殊请求会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求）。
实现：
CORS需要浏览器和服务器同时支持
1 浏览器端都有浏览器自动完成，无需操心（IE浏览器不能低于IE10）
2 服务端可通过拦截器统一实现，不必每次都去进行跨域判定的编写（SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了所讲的判定逻辑）

#### 本地存储和cookie和session的区别

cookie和session都是用来跟踪浏览器用户身份的会话方式
cookie在浏览器和服务器间来回传递，数据保存在客户端。考虑到减轻服务器性能方面，用cookie
session数据保存在服务器端，安全性高。但是当访问增多，会比较占用你服务器的性能
sessionStorage和localStorage是把数据保存在本地浏览器上，主要用于信息保存。
localStorage所存储的信息是永久保存的，除非手动去remove；存放的数据大小一般为5Mb
sessionStorage仅在当前会话下有效，关闭页面或者浏览器后被清除。存放的数据一般为5Mb
Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，每次都会携带在HTTP请求头中  默认如果不设置有效期，那么他默认是随着窗口关闭而清除；存放的数据大约为4K左右

#### Cookie的弊端

每个特定的域名下最多生成20个cookie
安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息
有些状态不可能保存在客户端



#### 前端路由的原理

前端路由的原理本质上就是在不刷新浏览器的请求下修改URL、检测URL的变化，截获URL的地址，通过解析、匹配路由规则从而实现UI的更新。路由的实现通常有两种形式一种是Hash模式，一种是History模式。

##### hash 模式

在Hash模式下，url中#后面的部分表示的是一个客户端状态，当这部分发生变化的时候，浏览器本身就不会刷新，这样就满足了第一个条件，即在不刷新浏览器的情况下修改浏览器链接，同时通过监听hashChange事件来监听URL中hash值的变化，触发相关函数，改变相关组件

##### history 模式

History模式利用了HTML5中history的API,history.pushState和history.replaceState这两个方法可以在不刷新页面的情况下，操作浏览器的历史记录，这样也就满足了第一个条件，然后通过监听popState事件来剪影URL的变化，从而触发相关函数，改变相关组件。

##### hash和history的区别

url 展示上，hash 模式有“#”，history 模式没有
刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由

兼容性，hash 可以支持低版本浏览器和 IE。

#### 前端路由和后端路由的区别

什么是路由
 路由是根据不同的url展示不同的内容或页面
什么是前端路由
 不向后台发送请求，不刷新页面，通过路由实现页面的变化，前后端分离
什么是后端路由
 向服务器发送请求，会刷新页面，前后端不能分离。在浏览器的地址栏中切换不同的url时，每次都向后台服务器发出请  求，服务器根据不同的响应不同的数据，浏览器接收到数据后再进行渲染

#### XML和JSON的区别

(1)数据体积方面。
JSON相对于XML来讲，数据的体积小，传递的速度更快些。
(2)数据交互方面。
JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
(3)数据描述方面。
JSON对数据的描述性比XML较差。
(4)传输速度方面。
JSON的速度要远远快于XML。

#### 对html语义化的理解

1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构
2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。

#### 判断脚本运行在浏览器还是node环境

通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中

#### ajax和axios、fetch的区别

##### 原生ajax

传统的ajax是指原生的XMLHttpRequest，最早出现的发送后端请求技术
多个请求之间如果有先后关系的话，就会出现回调地狱

```js
var xhr=new XMLHttpRequest();
```

##### jquery ajax

JQuery ajax 是对原生XHR的封装，除此以外还增添了对**JSONP**的支持

```js
ajax({
　　　　type:'post',
　　　　url:'test.php',
　　　　data:"name=test&&pwd=123456",
　　　　success:function(data){
　　　　　　console.log(data);
　　　　}
　　});
```

##### fetch

fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的
fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象

没有办法检测请求的进度，无法取消或超时处理
低版本浏览器和IE浏览器支持性不好	

##### axios

axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装
既解决回调地狱问题，又能很好地支持各个浏览器

#### 定时器精度问题

目前没发现能完全消除定时误差的方法

使用 web Worker将定时函数作为独立线程执行，兼容性不太好

#### web work

##### 定义

Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

```js
var worker = new Worker('work.js');
```



##### 注意点

Web Worker 有以下几个使用注意点。

（1）**同源限制**

分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

（2）**DOM 限制**

Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用`document`、`window`、`parent`这些对象。但是，Worker 线程可以`navigator`对象和`location`对象。

（3）**通信联系**

Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

（4）**脚本限制**

Worker 线程不能执行`alert()`方法和`confirm()`方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

（5）**文件限制**

Worker 线程无法读取本地文件，即不能打开本机的文件系统（`file://`），它所加载的脚本，必须来自网络。

#### 随机数

 2~10 范围内的值，其中包含 2 和 10 

```js
function selectFrom(lowerValue, upperValue) { 
 let choices = upperValue - lowerValue + 1; 
 return Math.floor(Math.random() * choices + lowerValue); 
} 
let num = selectFrom(2,10);
```

#### 长列表优化

##### 中级方法

虚拟列表是一个有效的设计思路。即永远只渲染当前用户可见，以及其前后的几个元素。监听滑动事件 (scroll event)，在滑动的时候调整当前窗口的可见元素，并渲染出来。这样可以大大节约插入和移除大量 DOM 元素的时间，可以大大加快初次渲染时间，而且渲染时间不随着数据量增加而增加

无限滚动加载，就是懒加载，就是在滚动到页面底部的时候，再去加载剩余的数据，说白了也是对数据进行分页，一种常见的首屏优化方案

##### 高级方法

使用js缓冲器来分片处理100万条数据

```js
function multistep(steps,args,callback){
    var tasks = steps.concat();

    setTimeout(function(){
        var task = tasks.shift();
        task.apply(null, args || []);   //调用Apply参数必须是数组

        if(tasks.length > 0){
            setTimeout(arguments.callee, 25);
        }else{
            callback();
        }
    },25);
}
```

通过**web worker**来将需要在前端进行大量计算的逻辑移入进去, 保证js主进程的快速响应, 让**web worker**线程在后台计算, 计算完成后再通过**web worker**的通信机制来通知主进程

### 前端监控和前端埋点

#### 简介

在线上项目中,需要统计产品中用户行为和使用情况，从而可以从用户和产品的角度去了解用户群体，从而升级和迭代产品，使其更加贴近用户。用户行为数据可以通过前端数据监控的方式获得，除此之外，前端还需要实现性能监控和异常监控。性能监控包括首屏加载时间、白屏时间、http请求时间和http响应时间。异常监控包括前端脚本执行报错等。

实现前端监控有三个步骤：前端埋点和上报、数据处理和数据分析。

#### 前端监控

前端监控可以分为三类：数据监控、性能监控和异常监控

数据监控，顾名思义就是监听用户的行为常见的数据监控包括：

- PV/UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数
- 用户在每一个页面的停留时间
- 用户通过什么入口来访问该网页
- 用户在相应的页面中触发的行为

性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：

- 不同用户，不同机型和不同系统下的首屏加载时间
- 白屏时间
- http等请求的响应时间
- 静态资源整体下载时间
- 页面渲染时间
- 页面交互动画完成时间

异常监控，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：

- Javascript的异常监控
- 样式丢失的异常监控

#### 常用前端埋点方案

如何实现前端监控呢，实现前端监控的步骤为：前端埋点和上报、数据处理和数据分析。首要的步骤就是前端埋点和上报，也就是数据的收集阶段。数据收集的丰富性和准确性会影响对产品线上效果的判别结果。

目前常见的前端埋点方法分为三种：代码埋点、可视化埋点和无痕埋点

**代码埋点**

代码埋点，就是以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接将监听行为以某一种数据格式直接传递给server端。此外比如需要统计产品的PV和UV的时候，需要在网页的初始化时，发送用户的访问信息等

**可视化埋点**

通过可视化交互的手段，代替代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。

可视化埋点听起来比较高大上，实际上跟代码埋点还是区别不大。也就是用一个系统来实现手动插入代码埋点的过程。

**无埋点**

无埋点并不是说不需要埋点，而是全部埋点，前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析因此实现“无埋点”统计。

从语言层面实现无埋点也很简单，比如从页面的js代码中，找出dom上被绑定的事件，然后进行全埋点