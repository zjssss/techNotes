#### 异步加载js文件

##### defer 属性

加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本的执行需要等到文档所有元素解析完成之后，会在DOMContentLoaded事件触发执行之前

```js
<script src="test1.js" defer="defer"></script>
```

##### async 属性

表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行

```js
<script src="test1.js" async></script>
```

##### async和defer的区别

（1）defer和async在网络加载过程是一致的，都是异步执行的；
（2）两者的区别在于脚本加载完成之后何时执行，可以看出defer更符合大多数场景对应用脚本加载和执行的要求；
（3）如果存在多个有defer属性的脚本，那么它们是按照加载顺序执行脚本的；而对于async，它的加载和执行是紧紧挨着的，无论声明顺序如何，只要加载完成就立刻执行，它对于应用脚本用处不大，因为它完全不考虑依赖。

#####  动态创建DOM方式

```js
 function downloadJSAtOnload() { 
       var element = document.createElement("script"); 
       element.src = "test1.js"; 
       document.body.appendChild(element); 
   } 
```

##### 使用jQuery的getScript()方法

##### 使用setTimeout延迟方法

##### 让js最后加载

引入外部js脚本文件时，如果放入html的head中,则页面加载前该js脚本就会被加载入页面，而放入body中，则会按照页面从上倒下的加载顺序来运行javascript的代码，所以我们可以把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度

#### 浏览器内核

IE：triden(腾讯,猎豹,360 等浏览器)
FireFox:gecko(跨平台内核,windows,linux 和 mac os 中可以使用)
Chrome:Blink
Safari:webkit(苹果公司的内核,遨游浏览器,塞班手机浏览器,安卓默认浏览器)
未来:Mozilla 与三星也达成合作协议开发"下一代"浏览器渲染引擎 Servo.

#### WEB 标准以及前端页面三层

web 标准简单来说可以分为 结构层（html）、表现层（css）和行为层（js）
web 标准三层分离,使其更具有模块化

#### 从用户刷新网页开始, 一次 js 请求一般情况下有哪些地方会有缓存处理

DNS 缓存(成功访问后网站的域名、IP 地址信息缓存到本地）
CDN 缓存(内容分发网络,选择一个离用户最近的 CDN 边缘节点来响应用户的请求)
浏览器缓存(存储最近访问的过的页面,再次请求时,从本地磁盘显示文档来加速页面的阅览,节约网络的资源加速浏览)

#### 大量图片加载很慢,有哪些方法优化

图片懒加载（未可视区添加滚动事件  js库  Vue-Lazyload）
图片预加载
如果图片为 css 图片,可以使用 CSSsprite 精灵图、SVGsprite 矢量图、Iconfont 字体图标、Base64 等技术.
预先加载缩略图

#### src 与 href 的区别

src 用于替换当前元素(引入),href 用于在当前文档和引用资源之间确立联系(关联)
src指向外部资源（js脚本，img图片，iframe）的位置,指向的内容将会嵌入到文档中当前标签所在位置
当浏览器解析到该元素时,会暂停其他资源的下载和处理,直到将该资源加载、编译、执行完毕
href指向网络资源所在位置,建立和当前元素(锚点)或当前文档(链接)之间的链接

#### 哪些操作会造成内存泄漏

未声明的意外的全局变量引起的内存泄露（避免创建全局变量）
没有清理的DOM元素引用(手动删除)
被遗忘的定时器或者回调(手动删除定时器)
闭包引起的内存泄露(将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中)
控制台日志
循环(在两个对象彼此引用且彼此保留时,就会产生一个循环)

#### **ES6 防止内存泄漏**

ES6推出了两种新的数据结构：weakset 和 weakmap 。他们对值的引用都是不计入垃圾回收机制的，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存。

#### javascript 中的垃圾回收机制

解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。

在 Javascript 中,如果一个对象不再被引用,那么这个对象就会被回收.
如果两个对象互相引用,而不再被第 3 者所引用,那么这两个互相引用的对象也会被回收

 js中最常用的垃圾收集方式是标记清除，比较不常见的引用计数

#### 谈谈 this 对象的理解

普通函数中:this ==》window
定时器中:this==》window
构造函数中:this==》当前实例对象
对象的方法中:this==》当前实例对象
原型对象的方法中:this==》当前实例对象
事件处理函数中:this==》事件触发对象

定时器函数window
立即执行函数window

#### eval 是做什么的

把对应的字符串解析成 JS 代码并运行
eval()可能会被黑,如使用恶意代码获取权限
eval()非常耗性能（2次，一次是解析成js语句，一次是执行）

#### ajax 请求时,如何解析 json 数据

使用 eval() 或者 JSON.parse()解析

#### JavaScript 的同源策略

同源是一种安全协议,指的是:协议,域名,端口相同

#### 谈谈你认为怎样做能使项目做的更好

1)了解需求:不要以主观去认为需求,
2)代码的可维护性:便于后期开发和维护,拓展
3)清晰的文件目录:便于查找管理文件,优化 I/O
4)上线前严格的测试:确保上线没问题
5)良好的用户体验

#### javaScript作用域链

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。
如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

#### HTML5新特性

新增了一些语义化标签（header footer content）和input
canvas画布功能
draggable元素拖放
Geolocation 地理定位功能
用于媒介回放的 video 和 audio 元素
表单控件，calendar、date、time、email、url、search
web本地离线存储
离线web应用，启用缓存，可以离线访问，降低服务器压力
WebSocket长连接
媒体查询
新增的一些css3动画效果

#### js事件流

事件流描述的是页面中接受事件的顺序，微软称为事件冒泡，网景称为事件捕获
事件流包括三个阶段，分别是捕获阶段，目标阶段，冒泡阶段
当事件发生时，最先得到通知的是window，然后是document，由上至下直到真正触发事件的那个元素(目标元素)为止，这个过程就是捕获。
接下来，事件会从目标元素开始起泡，由下至上逐级依次传播，直到window对象为止，这个过程就是冒泡。

事件代理的好处:利用事件冒泡，只绑定一个函数就可以处理一类事件
优化性能（每个函数都是一个对象，对象就要占据内存，内存大了性能自然就慢了）
当新元素绑添加进来的时候不需要再次绑定事件，通过冒泡就可以触发

阻止事件冒泡和捕获：e. stopPropagation()
阻止默认事件：e.preventDefault()

#### js数据类型

js数据类型被分为了两大类型：基本类型和引用类型（7种）
基本类型：Undefined,Null,Boolean,Number,String
引用类型：Object（Array,Date,RegExp，Function） symbol

##### 基本方法

typeof 用于判断基本类型

instance 用于判断引用类型

##### 判断js数据类型通用方法

```js
Object.prototype.toString.call() / ({}).toString.call()

var   gettype=Object.prototype.toString
 
gettype.call('aaaa')  // 输出 [object String]
 
gettype.call(2222)  // 输出 [object Number]
 
gettype.call(true)  // 输出 [object Boolean]
 
gettype.call(undefined)  // 输出 [object Undefined]
 
gettype.call(null)  // 输出 [object Null]
 
gettype.call({})  // 输出 [object Object]
 
gettype.call([])  // 输出 [object Array]
gettype.call(function(){})  // 输出 [object Function]
```

#### dom（浏览器）渲染的过程

浏览器解析html源码，然后创建一个DOM树。
浏览器解析CSS代码，计算出最终的样式数据（CSS树）。
创建完DOM树并得到最终的样式数据（CSS树）之后，构建一个渲染树。
当渲染树创建完成之后，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

#### 一个页面从输入 URL 到页面加载显示完成,这个过程中都发生了什么

（1）输入网址，将域名解析成IP地址（解析url）
（2）检查浏览器缓存
（3）开始DNS解析
（4）浏览器与服务器建立tcp协议连接（三次握手，建立连接）（TCP/IP连接）
（5）浏览器发送http请求，请求url对应的资源
（6）服务器处理http请求，给浏览器返回响应的资源
（7）接收到服务器响应内容之后，浏览器的html解析器会将HTML文件解析成一个DOM树，将CSS解析成一个CSS树，根据DOM树和CSS树来构建 Render Tree(渲染树)。根据渲染树的对应关系 在客户端呈现内容画面
（8）断开TCP连接

#### 回流（Reflow）与重绘（Repaint）

##### 回流

当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，
浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），
然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。

##### 重绘

当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，
浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。

##### 对比

由此我们可以看出，重绘不一定导致回流，回流一定会导致重绘。
硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。

#### 节流函数和防抖函数

“节流”与“防抖”的本质： 这两个东西都以闭包的形式存在。用 setTimeout 来控制事件的触发频率。
节流函数：当你触发一个事件后，在一段时间内，再次触发是不启作用的，因为有一个冷却时间。
防抖函数：当你在一定时间内多次触发一个事件时，他只会在你最后触发以后，采取执行查询操作。

完整版封装一般我们都使用lodash封装好的

##### 防抖

```js
function debounce(fn,delay){
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer) 
        }
        timer = setTimeout(fn,delay) // 简化写法
    }
}
// 然后是旧代码
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log('滚动条位置：' + scrollTop);
}
window.onscroll = debounce(showTop,1000)
```

##### 节流

加上一个状态位`valid`来表示当前函数是否处于工作状态

也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在

```js
function throttle(fn,delay){
    let valid = true
    return function() {
       if(!valid){
           //休息时间 暂不接客
           return false 
       }
       // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false
        setTimeout(() => {
            fn()
            valid = true;
        }, delay)
    }
}
```



#### 前端javaScript模块化的发展史

1 IIFE：使用自执行函数来编写模块化  特点：在一个单独的函数作用域中执行代码，避免变量冲突
2 AMD： 使用requireJS 来编写模块化，特点：提前执行，前置依赖。（异步模块定义）
3 CMD： 使用seaJS 来编写模块化，特点：延迟执行，就近依赖，按需加载。
4 CommonJS： nodejs 中自带的模块化（同步模块定义）
5 UMD：兼容AMD，CommonJS 模块化语法
       UMD的实现:
       1 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。
       2 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。
       3 前两个都不存在，则将模块公开到全局（window或global）
6 ES Modules： ES6 引入的模块化，支持import 来引入另一个 js 。

#### CommonJS

CommonJS是一种被广泛使用的js模块化规范，核心思想是通过require方法来同步加载依赖的其他模块，通过module.exports导出需要暴露的接口。
优点:
代码可复用于 Node.js 环境下井运行,通过 Npm 发布的很多第三方模块都采用了 CommonJS 规范
缺点：代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5



#### 代码优化

代码量(命名空间,封闭空间,模块化 mvc..)
拆分函数避免函数过于臃肿:单一职责原则
适当的注释,尤其是一些复杂的业务逻辑或者是计算逻辑,都应该写出这个业务逻辑的具体过程
内存管理,尤其是闭包中的变量释放



#### 平时如何管理你的项目,如何设计突发大规模并发架构

1)先期团队必须确定好全局样式(globe.css),编码模式(utf-8) 等
2)编写习惯必须一致(例如都是采用继承式的写法,单样式都写成一行);
3)标注样式编写人,各模块都及时标注(标注关键样式调用的地方);
4)页面进行标注(例如 页面 模块 开始和结束);
5)CSS 跟 HTML 分文件夹并行存放,命名都得统一(例如 style.css)
6)JS 分文件夹存放 命民以该 JS 功能为准英文翻译;
7)图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理

#### 一个完整的URL应该包括哪些

一个完整的URL包括：服务方或协议，主机地址或端口，资源的具体地址
通过URL可以指定的主要有以下几种：http、ftp、gopher、telnet、file等。

#### 关于跨域（cors怎么解决跨域）

跨域问题的出现，是因为浏览器的同源策略对ajax请求进行阻拦了
解决方法：CORS跨域资源共享，nginx反向代理，node代理服务器，后端设置响应头（response.setHeader("Access-Control-Allow-Origin", "*")）
1 CORS是一个W3C标准，全称是"跨域资源共享"
2 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制
3 浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求（特殊请求会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求）。
实现：
CORS需要浏览器和服务器同时支持
1 浏览器端都有浏览器自动完成，无需操心（IE浏览器不能低于IE10）
2 服务端可通过拦截器统一实现，不必每次都去进行跨域判定的编写（SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了所讲的判定逻辑）

#### 本地存储和cookie和session的区别

cookie和session都是用来跟踪浏览器用户身份的会话方式
cookie在浏览器和服务器间来回传递，数据保存在客户端。考虑到减轻服务器性能方面，用cookie
session数据保存在服务器端，安全性高。但是当访问增多，会比较占用你服务器的性能
sessionStorage和localStorage是把数据保存在本地浏览器上，主要用于信息保存。
localStorage所存储的信息是永久保存的，除非手动去remove；存放的数据大小一般为5Mb
sessionStorage仅在当前会话下有效，关闭页面或者浏览器后被清除。存放的数据一般为5Mb
Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，每次都会携带在HTTP请求头中  默认如果不设置有效期，那么他默认是随着窗口关闭而清除；存放的数据大约为4K左右

#### Cookie的弊端

每个特定的域名下最多生成20个cookie
安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息
有些状态不可能保存在客户端



#### 路由模式的原理

hash 模式：
#后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面
通过监听 hashchange 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。

history 模式：
history 模式的实现，主要是 HTML5 标准发布的两个 API，pushState 和 replaceState，这两个 API 可以改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作

区别
url 展示上，hash 模式有“#”，history 模式没有
刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由

兼容性，hash 可以支持低版本浏览器和 IE。

#### 前端路由和后端路由的区别

什么是路由
 路由是根据不同的url展示不同的内容或页面
什么是前端路由
 不向后台发送请求，不刷新页面，通过路由实现页面的变化，前后端分离
什么是后端路由
 向服务器发送请求，会刷新页面，前后端不能分离。在浏览器的地址栏中切换不同的url时，每次都向后台服务器发出请  求，服务器根据不同的响应不同的数据，浏览器接收到数据后再进行渲染

#### XML和JSON的区别

(1)数据体积方面。
JSON相对于XML来讲，数据的体积小，传递的速度更快些。
(2)数据交互方面。
JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
(3)数据描述方面。
JSON对数据的描述性比XML较差。
(4)传输速度方面。
JSON的速度要远远快于XML。

#### 对html语义化的理解

1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构
2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。

#### 判断脚本运行在浏览器还是node环境

通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中

#### ajax和axios、fetch的区别

##### 原生ajax

传统的ajax是指原生的XMLHttpRequest，最早出现的发送后端请求技术
多个请求之间如果有先后关系的话，就会出现回调地狱

```js
var xhr=new XMLHttpRequest();
```

##### jquery ajax

JQuery ajax 是对原生XHR的封装，除此以外还增添了对**JSONP**的支持

```js
ajax({
　　　　type:'post',
　　　　url:'test.php',
　　　　data:"name=test&&pwd=123456",
　　　　success:function(data){
　　　　　　console.log(data);
　　　　}
　　});
```

##### fetch

fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的
fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象

没有办法检测请求的进度，无法取消或超时处理
低版本浏览器和IE浏览器支持性不好	

##### axios

axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装
既解决回调地狱问题，又能很好地支持各个浏览器

#### 定时器精度问题

目前没发现能完全消除定时误差的方法

使用 web Worker将定时函数作为独立线程执行，兼容性不太好

#### web work

##### 定义

Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

```js
var worker = new Worker('work.js');
```



##### 注意点

Web Worker 有以下几个使用注意点。

（1）**同源限制**

分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

（2）**DOM 限制**

Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用`document`、`window`、`parent`这些对象。但是，Worker 线程可以`navigator`对象和`location`对象。

（3）**通信联系**

Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

（4）**脚本限制**

Worker 线程不能执行`alert()`方法和`confirm()`方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

（5）**文件限制**

Worker 线程无法读取本地文件，即不能打开本机的文件系统（`file://`），它所加载的脚本，必须来自网络。

#### 随机数

 2~10 范围内的值，其中包含 2 和 10 

```js
function selectFrom(lowerValue, upperValue) { 
 let choices = upperValue - lowerValue + 1; 
 return Math.floor(Math.random() * choices + lowerValue); 
} 
let num = selectFrom(2,10);
```

#### 长列表优化

##### 中级方法

虚拟列表是一个有效的设计思路。即永远只渲染当前用户可见，以及其前后的几个元素。监听滑动事件 (scroll event)，在滑动的时候调整当前窗口的可见元素，并渲染出来。这样可以大大节约插入和移除大量 DOM 元素的时间，可以大大加快初次渲染时间，而且渲染时间不随着数据量增加而增加

无限滚动加载，就是懒加载，就是在滚动到页面底部的时候，再去加载剩余的数据，说白了也是对数据进行分页，一种常见的首屏优化方案

##### 高级方法

使用js缓冲器来分片处理100万条数据

```js
function multistep(steps,args,callback){
    var tasks = steps.concat();

    setTimeout(function(){
        var task = tasks.shift();
        task.apply(null, args || []);   //调用Apply参数必须是数组

        if(tasks.length > 0){
            setTimeout(arguments.callee, 25);
        }else{
            callback();
        }
    },25);
}
```

通过**web worker**来将需要在前端进行大量计算的逻辑移入进去, 保证js主进程的快速响应, 让**web worker**线程在后台计算, 计算完成后再通过**web worker**的通信机制来通知主进程